package insecure

import (
	"fmt"
	"net/http"
	"vhu_bmwa/models"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

// ListProductsHandler demonstrates multiple security vulnerabilities:
// 1. SQL injection through string concatenation
// 2. No input validation
// 3. No authentication required
// 4. Sensitive error exposure
func ListProductsHandler(db *gorm.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		// VULNERABILITY: SQL Injection through string concatenation
		query := "SELECT * FROM insecure_products WHERE 1=1"

		// VULNERABILITY: Direct string concatenation without sanitization
		if name := c.Query("name"); name != "" {
			query += fmt.Sprintf(" AND name LIKE '%%%s%%'", name)
		}

		if description := c.Query("description"); description != "" {
			query += fmt.Sprintf(" AND description LIKE '%%%s%%'", description)
		}

		if price := c.Query("price"); price != "" {
			query += fmt.Sprintf(" AND price = %s", price)
		}

		var products []models.InsecureProduct
		result := db.Raw(query).Scan(&products)
		if result.Error != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"error":     "Failed to fetch products",
				"sql_error": result.Error.Error(), // VULNERABILITY: Exposing SQL error
				"query":     query,                // VULNERABILITY: Exposing SQL query
			})
			return
		}

		c.JSON(http.StatusOK, products)
	}
}

// CreateProductHandler demonstrates multiple security vulnerabilities:
// 1. No authentication required
// 2. No input validation
// 3. SQL injection
// 4. Sensitive error exposure
func CreateProductHandler(db *gorm.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		var product models.InsecureProduct
		if err := c.ShouldBindJSON(&product); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}

		// VULNERABILITY: SQL Injection through string concatenation
		query := fmt.Sprintf(
			"INSERT INTO insecure_products (name, description, price, created_at, updated_at) VALUES ('%s', '%s', %f, NOW(), NOW())",
			product.Name,
			product.Description,
			product.Price,
		)

		result := db.Exec(query)
		if result.Error != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"error":     "Failed to create product",
				"sql_error": result.Error.Error(), // VULNERABILITY: Exposing SQL error
				"query":     query,                // VULNERABILITY: Exposing SQL query
			})
			return
		}

		c.JSON(http.StatusOK, gin.H{
			"message": "Product created successfully",
			"debug": gin.H{ // VULNERABILITY: Exposing debug information
				"query":         query,
				"affected_rows": result.RowsAffected,
			},
		})
	}
}

// UpdateProductHandler demonstrates multiple security vulnerabilities:
// 1. No authentication required
// 2. No input validation
// 3. SQL injection
// 4. Sensitive error exposure
func UpdateProductHandler(db *gorm.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		id := c.Param("id")

		var product models.InsecureProduct
		if err := c.ShouldBindJSON(&product); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}

		// VULNERABILITY: SQL Injection through string concatenation
		query := fmt.Sprintf(
			"UPDATE insecure_products SET name = '%s', description = '%s', price = %f, updated_at = NOW() WHERE id = %s",
			product.Name,
			product.Description,
			product.Price,
			id,
		)

		result := db.Exec(query)
		if result.Error != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"error":     "Failed to update product",
				"sql_error": result.Error.Error(), // VULNERABILITY: Exposing SQL error
				"query":     query,                // VULNERABILITY: Exposing SQL query
			})
			return
		}

		if result.RowsAffected == 0 {
			c.JSON(http.StatusNotFound, gin.H{
				"error": "Product not found",
				"debug": gin.H{ // VULNERABILITY: Exposing debug information
					"id":    id,
					"query": query,
				},
			})
			return
		}

		c.JSON(http.StatusOK, gin.H{
			"message": "Product updated successfully",
			"debug": gin.H{ // VULNERABILITY: Exposing debug information
				"query":         query,
				"affected_rows": result.RowsAffected,
			},
		})
	}
}

// DeleteProductHandler demonstrates multiple security vulnerabilities:
// 1. No authentication required
// 2. No input validation
// 3. SQL injection
// 4. Sensitive error exposure
func DeleteProductHandler(db *gorm.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		id := c.Param("id")

		// VULNERABILITY: SQL Injection through string concatenation
		query := fmt.Sprintf("DELETE FROM insecure_products WHERE id = %s", id)

		result := db.Exec(query)
		if result.Error != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"error":     "Failed to delete product",
				"sql_error": result.Error.Error(), // VULNERABILITY: Exposing SQL error
				"query":     query,                // VULNERABILITY: Exposing SQL query
			})
			return
		}

		if result.RowsAffected == 0 {
			c.JSON(http.StatusNotFound, gin.H{
				"error": "Product not found",
				"debug": gin.H{ // VULNERABILITY: Exposing debug information
					"id":    id,
					"query": query,
				},
			})
			return
		}

		c.JSON(http.StatusOK, gin.H{
			"message": "Product deleted successfully",
			"debug": gin.H{ // VULNERABILITY: Exposing debug information
				"query":         query,
				"affected_rows": result.RowsAffected,
			},
		})
	}
}
